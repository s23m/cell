/* ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is S23M. * * The Initial Developer of the Original Code is * The S23M Foundation. * Portions created by the Initial Developer are * Copyright (C) 2012 The S23M Foundation. * All Rights Reserved. * * Contributor(s): * Andrew Shewring * ***** END LICENSE BLOCK ***** */package org.s23m.cell.core.collections;/** * Lazy initialization of a field value based on the (correct) double checked * locking idiom by Joshua Bloch. * <p> * See "Effective Java, Second Edition", p. 283 * From http://blog.pdark.de/2010/03/04/java-tricks-lazy-initialization/ */public abstract class LazyValue<T> {	private volatile T field;	/**	 * Return the value.	 * 	 * <p>	 * If the value is still <code>null</code>, the method will block and invoke	 * <code>computeValue()</code>. Calls from other threads will wait until the	 * call from the first thread completes.	 */	public T get() {		T result = field;		if (result == null) {			// First check (no locking)			synchronized (this) {				result = field;				if (result == null) {					// Second check (with locking)					field = result = computeValue();				}			}		}		return result;	}	/**	 * Computes the value (called at most once)	 */	protected abstract T computeValue();}
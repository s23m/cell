/* ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is S23M. * * The Initial Developer of the Original Code is * The S23M Foundation. * Portions created by the Initial Developer are * Copyright (C) 2012 The S23M Foundation. * All Rights Reserved. * * Contributor(s): * Andrew Shewring * ***** END LICENSE BLOCK ***** */package org.s23m.cell.core.concurrency.ehcache;/** *  Copyright 2003-2010 Terracotta, Inc. * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.SortedMap;import java.util.TreeMap;import java.util.concurrent.TimeoutException;import java.util.concurrent.atomic.AtomicInteger;/** * Original class is net.sf.ehcache.concurrent.StripedReadWriteLockSync *  * Provides a number of Sync which allow fine-grained concurrency. Rather than locking a cache or a store, * the individual elements or constituent objects can be locked. This dramatically increases * the possible concurrency. * <p/> * The more stripes, the higher the concurrency. To be threadsafe, the instance of CacheLockProvider needs to be * maintained for the entire life of the cache or store, so there is some added memory use. * <p/> * Though a new class, this code has been refactored from <code>BlockingCache</code>, where it has been in use * in highly concurrent production environments for years. * <p/> * Based on the lock striping concept from Brian Goetz. See Java Concurrency in Practice 11.4.3 *  * @author Alex Snaps */public class StripedReadWriteLockSync implements CacheLockProvider {	/**	 * The default number of locks to use. Must be a power of 2.	 * <p/>	 * The choice of 2048 enables 2048 concurrent operations per cache or cache store, which should be enough for most	 * uses.	 */	public  static final int    DEFAULT_NUMBER_OF_MUTEXES = 2048;	private final ReadWriteLockSync[] mutexes;	private final int                 numberOfStripes;	/**	 * Constructs a striped mutex with the default 2048 stripes.	 */	public StripedReadWriteLockSync() {		this(DEFAULT_NUMBER_OF_MUTEXES);	}	/**	 * Constructs a striped mutex with the default 2048 stripes.	 * <p/>	 * The number of stripes determines the number of concurrent operations per cache or cache store.	 * @param numberOfStripes - must be a factor of two	 */	public StripedReadWriteLockSync(final int numberOfStripes) {		if (numberOfStripes % 2 != 0) {			throw new CacheException("Cannot create a CacheLockProvider with an odd number of stripes");		}		if (numberOfStripes == 0) {			throw new CacheException("A zero size CacheLockProvider does not have useful semantics.");		}		this.numberOfStripes = numberOfStripes;		mutexes = new ReadWriteLockSync[numberOfStripes];		for (int i = 0; i < numberOfStripes; i++) {			mutexes[i] = new ReadWriteLockSync();		}	}	/**	 * Gets the Sync Stripe to use for a given key.	 * <p/>	 * This lookup must always return the same Sync for a given key.	 * <p/>	 * @param key the key	 * @return one of a limited number of Sync's.	 */	public ReadWriteLockSync getSyncForKey(final Object key) {		final int lockNumber = ConcurrencyUtil.selectLock(key, numberOfStripes);		return mutexes[lockNumber];	}	/**	 * {@inheritDoc}	 */	public Sync[] getAndWriteLockAllSyncForKeys(final Object... keys) {		final SortedMap<ReadWriteLockSync, AtomicInteger> locks = getLockMap(keys);		final Sync[] syncs = new Sync[locks.size()];		int i = 0;		for (final Map.Entry<ReadWriteLockSync, AtomicInteger> entry : locks.entrySet()) {			while (entry.getValue().getAndDecrement() > 0) {				entry.getKey().lock(LockType.WRITE);			}			syncs[i++] = entry.getKey();		}		return syncs;	}	/**	 * {@inheritDoc}	 */	public Sync[] getAndWriteLockAllSyncForKeys(final long timeout, final Object... keys) throws TimeoutException {		final SortedMap<ReadWriteLockSync, AtomicInteger> locks = getLockMap(keys);		boolean lockHeld;		final List<ReadWriteLockSync> heldLocks = new ArrayList<ReadWriteLockSync>();		final Sync[] syncs = new Sync[locks.size()];		int i = 0;		for (final Map.Entry<ReadWriteLockSync, AtomicInteger> entry : locks.entrySet()) {			while (entry.getValue().getAndDecrement() > 0) {				try {					final ReadWriteLockSync writeLockSync = entry.getKey();					lockHeld = writeLockSync.tryLock(LockType.WRITE, timeout);					if (lockHeld) {						heldLocks.add(writeLockSync);					}				} catch (final InterruptedException e) {					lockHeld = false;				}				if (!lockHeld) {					for (int j = heldLocks.size() - 1; j >= 0; j--) {						final ReadWriteLockSync readWriteLockSync = heldLocks.get(j);						readWriteLockSync.unlock(LockType.WRITE);					}					throw new TimeoutException("could not acquire all locks in " + timeout + " ms");				}			}			syncs[i++] = entry.getKey();		}		return syncs;	}	/**	 * {@inheritDoc}	 */	public void unlockWriteLockForAllKeys(final Object... keys) {		final SortedMap<ReadWriteLockSync, AtomicInteger> locks = getLockMap(keys);		for (final Map.Entry<ReadWriteLockSync, AtomicInteger> entry : locks.entrySet()) {			while (entry.getValue().getAndDecrement() > 0) {				entry.getKey().unlock(LockType.WRITE);			}		}	}	private SortedMap<ReadWriteLockSync, AtomicInteger> getLockMap(final Object... keys) {		final SortedMap<ReadWriteLockSync, AtomicInteger> locks = new TreeMap<ReadWriteLockSync, AtomicInteger>();		for (final Object key : keys) {			final ReadWriteLockSync syncForKey = getSyncForKey(key);			if (locks.containsKey(syncForKey)) {				locks.get(syncForKey).incrementAndGet();			} else {				locks.put(syncForKey, new AtomicInteger(1));			}		}		return locks;	}}
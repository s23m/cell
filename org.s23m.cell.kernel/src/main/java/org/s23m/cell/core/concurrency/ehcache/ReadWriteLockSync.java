/* ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is S23M. * * The Initial Developer of the Original Code is * The S23M Foundation. * Portions created by the Initial Developer are * Copyright (C) 2012 The S23M Foundation. * All Rights Reserved. * * Contributor(s): * Andrew Shewring * ***** END LICENSE BLOCK ***** */package org.s23m.cell.core.concurrency.ehcache;/** *  Copyright 2003-2010 Terracotta, Inc. * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * Original class is net.sf.ehcache.concurrent.ReadWriteLockSync *  * A simple ReadWriteLock synchronizer. * * @author Alex Snaps */public class ReadWriteLockSync implements Sync, Comparable<ReadWriteLockSync> {	private final ReentrantReadWriteLock rrwl = new ReentrantReadWriteLock();	private final Lock readLock = rrwl.readLock();	private final Lock writeLock = rrwl.writeLock();	/**	 * {@inheritDoc}	 */	public void lock(final LockType type) {		getLock(type).lock();	}	/**	 * {@inheritDoc}	 */	public boolean tryLock(final LockType type, final long msec) throws InterruptedException {		return getLock(type).tryLock(msec, TimeUnit.MILLISECONDS);	}	/**	 * {@inheritDoc}	 */	public void unlock(final LockType type) {		getLock(type).unlock();	}	private Lock getLock(final LockType type) {		switch (type) {		case READ:			return readLock;		case WRITE:			return writeLock;		default:			throw new IllegalArgumentException("We don't support any other lock type than READ or WRITE!");		}	}	/**	 * {@inheritDoc}	 */	public boolean isHeldByCurrentThread(final LockType type) {		switch (type) {		case READ:			throw new UnsupportedOperationException("Querying of read lock is not supported.");		case WRITE:			return rrwl.isWriteLockedByCurrentThread();		default:			throw new IllegalArgumentException("We don't support any other lock type than READ or WRITE!");		}	}	/**	 * {@inheritDoc}	 */	public int compareTo(final ReadWriteLockSync o) {		return  String.valueOf(hashCode()).compareTo(String.valueOf(o.hashCode()));	}}
/* ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is S23M. * * The Initial Developer of the Original Code is * The S23M Foundation. * Portions created by the Initial Developer are * Copyright (C) 2012 The S23M Foundation. * All Rights Reserved. * * Contributor(s): * Andrew Shewring * ***** END LICENSE BLOCK ***** */package org.s23m.cell.core.collections;import java.util.Iterator;import java.util.UUID;/** * A generator for a sequence of {@link UUID}s of limited length. It * uses a fixed value for the most significant bits and successively * increments the value supplied for the least significant bits, given * a starting value and the length of the sequence. *  * Note that this generator is <b>not</b> thread safe. External * synchronisation should be used if required. */public class UUIDSequence implements FixedSizeIterable<UUID> {	private final int sequenceLength;	private final Iterator<UUID> uuidIterator;	public UUIDSequence(final long mostSignificantBits,			final long initialValueForLeastSignificantBits,			final int sequenceLength) {		if (sequenceLength < 0) {			throw new IllegalArgumentException("Sequence length must be positive");		}		// disallow overflow		if (initialValueForLeastSignificantBits <= Long.MAX_VALUE && initialValueForLeastSignificantBits + sequenceLength < 0) {			throw new IllegalArgumentException("Initial value for least significant bits and sequence length are incompatible");		}		this.sequenceLength = sequenceLength;		this.uuidIterator = new Iterator<UUID>() {			// set initial value			private long leastSignificantBits = initialValueForLeastSignificantBits;			public boolean hasNext() {				return initialValueForLeastSignificantBits + sequenceLength > leastSignificantBits;			}			public UUID next() {				final UUID result = createUUID(mostSignificantBits, leastSignificantBits);				// advance value of least significant bits for next use				leastSignificantBits++;				return result;			}			public void remove() {				throw new UnsupportedOperationException("Not implemented: read-only sequence");			}		};	}	public Iterator<UUID> iterator() {		return uuidIterator;	}	public int size() {		return sequenceLength;	}	private UUID createUUID(final long mostSignificantBits, final long leastSignificantBits) {		// example: "02848590-89cb-11df-a4ee-0800200c9a66"		final int length = 16;		final String most = leftPadWithZeros(Long.toHexString(mostSignificantBits), length);		final String least = leftPadWithZeros(Long.toHexString(leastSignificantBits), length);		final String hexString = most + least;		final String withDashes = hexString.substring(0, 8)				+ "-"				+ hexString.substring(8, 12)				+ "-"				+ hexString.substring(12, 16)				+ "-"				+ hexString.substring(16, 20)				+ "-"				+ hexString.substring(20);		return UUID.fromString(withDashes);	}	private String leftPadWithZeros(final String digits, final int requiredLength) {		String result = digits;		final int length = result.length();		if (length < requiredLength) {			result = repeat(requiredLength - length, "0") + result;		}		return result;	}	private String repeat(final int n, final String s) {		return new String(new char[n]).replace("\0", s);	}}
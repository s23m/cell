/* ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is S23M. * * The Initial Developer of the Original Code is * The S23M Foundation. * Portions created by the Initial Developer are * Copyright (C) 2012 The S23M Foundation. * All Rights Reserved. * * Contributor(s): * Andrew Shewring * ***** END LICENSE BLOCK ***** */package org.s23m.cell.core;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import junit.framework.TestCase;import org.s23m.cell.S23MKernel;import org.s23m.cell.Set;import org.s23m.cell.api.models.S23MSemanticDomains;import org.s23m.cell.core.F_Instantiation;import org.s23m.cell.core.OrderedSet;public class OrderedSetTest extends TestCase {	@Override	protected void setUp() throws Exception {		S23MKernel.boot();	}	public void testSize() {		final OrderedSet container = new OrderedSet();		assertEquals(0, container.size());		container.add(createOrderedSet());		assertEquals(1, container.size());		container.add(createOrderedSet());		assertEquals(2, container.size());	}	public void testIsEmpty() {		final OrderedSet container = new OrderedSet();		assertTrue(container.isEmpty());		container.add(createOrderedSet());		assertFalse(container.isEmpty());	}	public void testExtractFirst() {		final OrderedSet container = new OrderedSet();		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractFirst());		final OrderedSet o = createOrderedSet();		container.add(o);		assertEquals(o, container.extractFirst());		final OrderedSet o2 = createOrderedSet();		container.add(o2);		assertEquals(o, container.extractFirst());	}	public void testExtractSecond() {		final OrderedSet container = new OrderedSet();		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractSecond());		final OrderedSet a = createOrderedSet();		container.add(a);		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractSecond());		final OrderedSet b = createOrderedSet();		container.add(b);		assertEquals(b, container.extractSecond());		final OrderedSet c = createOrderedSet();		container.add(c);		assertEquals(b, container.extractSecond());	}	public void testExtractLast() {		final OrderedSet container = new OrderedSet();		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractLast());		final OrderedSet a = createOrderedSet();		container.add(a);		assertEquals(a, container.extractLast());		final OrderedSet b = createOrderedSet();		container.add(b);		assertEquals(b, container.extractLast());	}	public void testExtractNext() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractNext(a));		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		assertEquals(b, container.extractNext(a));		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractNext(b));	}	public void testExtractPrevious() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractPrevious(a));		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		assertEquals(a, container.extractPrevious(b));		assertEquals(S23MSemanticDomains.is_NOTAPPLICABLE, container.extractPrevious(a));	}	public void testToArray() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		final Set[] expected = new Set[]{a, b};		final Set[] result = container.toArray();		checkArrayEquality(expected, result);	}	public void testToArrayWithSetArrayParameter() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		final Set[] expected = new Set[]{a, b};		// array passed in is extended if necessary		final Set[] result = container.toArray(new Set[1]);		checkArrayEquality(expected, result);	}	public void testAsList() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		checkListEquality(Arrays.<Set>asList(a, b), container.asList());	}	public void testIterator() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		final Iterator<Set> iterator = container.iterator();		final List<Set> list = iteratorToList(iterator);		checkListEquality(Arrays.<Set>asList(a, b), list);	}	public void testListIterator() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		final ListIterator<Set> iterator = container.listIterator();		final List<Set> list = iteratorToList(iterator);		checkListEquality(Arrays.<Set>asList(a, b), list);	}	public void testContainsSemanticMatch() {		final OrderedSet container = new OrderedSet();		final OrderedSet a = createOrderedSet();		container.add(a);		final OrderedSet b = OrderedSet.createTransientOrderedSet();		container.add(b);		final OrderedSet c = new OrderedSet(F_Instantiation.identityFactory.minCardinality());		assertTrue(container.containsSemanticMatch(a));		assertTrue(container.containsSemanticMatch(b));		assertFalse(container.containsSemanticMatch(c));	}	public void testListIteratorWithIndexParameter() {		// TODO	}	public void testContainsRepresentation() {		// TODO	}	public void testContainsSemanticMatchesForAll() {		// TODO	}	public void testContainsAllRepresentations() {		// TODO	}	public void testFilter() {		// TODO	}	public void testFilterProperClass() {		// TODO	}	public void testFilterInstances() {		// TODO	}	public void testFilterArrows() {		// TODO	}	public void testFilterPolymorphic() {		// TODO	}	public void testUnion() {		// TODO	}	public void testIntersection() {		// TODO	}	public void testComplement() {		// TODO	}	public void testTransformToOrderedSetOfSemanticIdentities() {		// TODO	}	public void testAddSubscriber() {		// TODO	}	public void testRemoveSubscriber() {		// TODO	}	public void testNot() {		// TODO	}	public void testAndSet() {		// TODO	}	public void testOrSet() {		// TODO	}	public void testIncludesValue() {		// TODO	}	public void testAnd() {		// TODO	}	public void testOr() {		// TODO	}	public void testFilterByLinkedTo() {		// TODO	}	public void testFilterByLinkedFrom() {		// TODO	}	public void testFilterByLinkedFromAndTo() {		// TODO	}	public void testFilterArrowsSetSetSet() {		// TODO	}	public void testFilterByLinkedToVia() {		// TODO	}	public void testFilterByLinkedFromVia() {		// TODO	}	public void testFilterByLinkedFromAndToVia() {		// TODO	}	public void testFilterFrom() {		// TODO	}	public void testFilterTo() {		// TODO	}	public void testFilterFromAndTo() {		// TODO	}	public void testFilterByLinkedToSemanticRole() {		// TODO	}	public void testFilterByLinkedFromSemanticRole() {		// TODO	}	public void testFilterByLinkedFromAndToSemanticRole() {		// TODO	}	public void testIsEqualToSetSet() {		// TODO	}	public void testFilterBySemanticIdentity() {		// TODO	}	public void testFilterByEquivalenceClass() {		// TODO	}	public void testExtractUniqueMatchSet() {		// TODO	}	public void testExtractUniqueMatchIdentity() {		// TODO	}	public void testExtractUniqueMatchString() {		// TODO	}	public void testSetMaintenanceCommand() {		// TODO	}	private OrderedSet createOrderedSet() {		return new OrderedSet();	}	private List<Set> iteratorToList(final Iterator<Set> iterator) {		final List<Set> result = new ArrayList<Set>();		while (iterator.hasNext()) {			result.add(iterator.next());		}		return result;	}	private void checkListEquality(final List<Set> expected, final List<Set> result) {		assertEquals(expected.size(), result.size());		for (int i = 0; i < expected.size(); i++) {			assertEquals(expected.get(i), result.get(i));		}	}	private void checkArrayEquality(final Set[] expected, final Set[] result) {		assertEquals(expected.length, result.length);		for (int i = 0; i < expected.length; i++) {			assertEquals(expected[i], result[i]);		}	}}
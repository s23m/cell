/* ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is S23M. * * The Initial Developer of the Original Code is * The S23M Foundation. * Portions created by the Initial Developer are * Copyright (C) 2012 The S23M Foundation. * All Rights Reserved. * * Contributor(s): * Andrew Shewring * ***** END LICENSE BLOCK ***** */package org.s23m.cell.core.collections;import java.util.HashSet;import java.util.Iterator;import java.util.Set;import java.util.UUID;import junit.framework.TestCase;public class UUIDSequenceTest extends TestCase {	public void testIteratorLeastSignificantBitsIncrementing() {		final UUIDSequence generator = new UUIDSequence(0, 0, 3);		final Iterator<UUID> i = generator.iterator();		assertTrue(i.hasNext());		final UUID u1 = i.next();		assertEquals(0, u1.getMostSignificantBits());		assertEquals(0, u1.getLeastSignificantBits());		assertTrue(i.hasNext());		final UUID u2 = i.next();		assertEquals(0, u2.getMostSignificantBits());		assertEquals(1, u2.getLeastSignificantBits());		assertTrue(i.hasNext());		final UUID u3 = i.next();		assertEquals(0, u3.getMostSignificantBits());		assertEquals(2, u3.getLeastSignificantBits());	}	public void testIteratorSequenceLength() {		for (int length = 0; length < 10; length++) {			int count = 0;			final UUIDSequence sequence = new UUIDSequence(0, 0, length);			final Set<UUID> uuids = new HashSet<UUID>();			for (final UUID u : sequence) {				final boolean added = uuids.add(u);				assertTrue(added);				count++;			}			assertEquals(length, count);		}	}	public void testIteratorWithEmptySequence() {		final UUIDSequence generator = new UUIDSequence(0, 0, 0);		final Iterator<UUID> i = generator.iterator();		assertFalse(i.hasNext());	}	public void testIteratorBoundaryConditions() {		final UUIDSequence maxInitialValueGenerator = new UUIDSequence(0, Long.MAX_VALUE - 1, 1);		final Iterator<UUID> i1 = maxInitialValueGenerator.iterator();		assertTrue(i1.hasNext());		i1.next();		assertFalse(i1.hasNext());		final UUIDSequence maxMostSignificantBitsGenerator = new UUIDSequence(Long.MAX_VALUE, 0, 1);		final Iterator<UUID> i2 = maxMostSignificantBitsGenerator.iterator();		assertTrue(i2.hasNext());		i2.next();		assertFalse(i2.hasNext());	}	public void testIteratorInitialValueAndSequenceLengthCompatibilityCheck() {		try {			new UUIDSequence(0, Long.MAX_VALUE, 1);			fail("Exception should have been thrown due to incompatible parameters");		} catch (final IllegalArgumentException e) {			// expected		}		try {			new UUIDSequence(0, Long.MAX_VALUE - Integer.MAX_VALUE + 1, Integer.MAX_VALUE);			fail("Exception should have been thrown due to incompatible parameters");		} catch (final IllegalArgumentException e) {			// expected		}	}	public void testIteratorSequenceLengthCheck() {		try {			new UUIDSequence(0, 0, -1);			fail("Exception should have been thrown due to illegal sequence length");		} catch (final IllegalArgumentException e) {			// expected		}	}}